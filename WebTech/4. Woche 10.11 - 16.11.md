### JavaScript
#JS
- In JavaScript ist alles ein Objekt
	- Sammlung von Eigenschaften 
		- Werte und Namen (Funktionen sind auch Werte)
- JS ist prototypenbasiert, oder objektbasiert (nicht objektorientiert)
	- Ohne Klassen
	- Wiederverwendung durch Dekorieren
	- Vererbung durch Prototype Chain

**Objekthierachien**
- Keine Klassen
- Objekte sind Kopien eines anderen Objekts (Prototypobjekt)
- zusächtliche Eigenschaften möglich (dynamische erweitbar)
- Jedes Objekt vererbt die Eigenschaft des prototypes
- Ende property-Chain ist Objekt.prototype (prototype = Null)

**Vergleich Java und JavaScript**

| OO                                                                                    | JS                                                                                            |
| ------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------- |
| Objekt werden auf Grundlage der Klassen definiert                                     | Objekte werden Dynamisch auf der Grundlagen eines Prototypobjekt erzeugt                      |
| Klasse definieren mit einer Klassendefinition Instanziieren durch eines Konstruktions | Definieren und Erstellen von Objekte mit Konstruktor Funktion oder Object.create oder literal |
| Klassenhierarchie durch Vererbung                                                     | Objekthierarchie durch Zuweisen der Prototype-Eigenschaft                                     |
| Erben der Eigenschaften entlag der Class Chain                                        | Erben der Eigenschaften entlang der prototype chain                                           |
| statisch und zur Laufzeit nicht veränderbar                                           | dynamisch und zur Laufzeit veränderbar                                                        |

#### Closures:

```ad-abstract
title: Closures
Ein Closure ist eine Funktion, die Zugriff auf den Scope ihrer umfassenden Funktion hat, selbst nachdem die umschließende Funktion abgeschlossen wurde
```

- Obere Klasse definiert Variablen die Kontext Frei sind
- innere Klasse simuliert Java-private

#### Patterns:
- Eine Schnittstelle um mehrere Elemente ansprechen zu können
- getElementbyClassName ist die schnellste jedoch nicht immer unterstützt
- Lösung: JQuery $\Rightarrow$ Facade-Pattern
	- eine einfacht

**Software Design Pattern:**
- Konzeptionelle Pattern
- Strukturelle Pattern
- Verhaltensorientierte Pattern

```ad-note
title: Konzeptionelle Pattern
- Vorgehensweise der Erstellung (Objekte)
- Vereinfachung komplexe Prozesse
- Kapseln der Erstellung zu einem anderen Teil des Systems
- *Erzeugungsmuster*

Vertreter:
Constructor, Module, Factory, Singelton, Prototyp
```

```ad-note
title: Strukturelle Pattern
- Vereinfachen Beziehungen zwischen Objekten
- Schnittstellen für komplexe Strukturen
- Gesamtstruktur behalten bei Änderungen

Vertreter:
Facade, Adapter, Bridge, Composite, Decorator
```

```ad-note
title: Verhaltensorientierte Pattern
- Kommunikation zwischen verschiedenen Komponenten verbessern
- Vereinfachen komplexe Kontrollflüsse

Vertreter:
Observer, Mediator, Interpreter, Visitor
```

##### Konzeptionelle Pattern:
- Module Pattern:
	- private und public
	- simulieren von Klassen
	- begrenzt Global Scope:
		- Namens konflikte minimieren
		- Externer Scripte können Fehler verursachen
- Private durch Closures

| Vortele                                         | Nachteile                                         |
| ----------------------------------------------- | ------------------------------------------------- |
| Klare Struktur                                  | Zugriff auf privat und public schwerer            |
| Kapselung privater Daten                        | keine automatisierten Tests auf privaten Methoden |
| Public erreicht private aber Globel Scope nicht | Bugs finden                                       |
|                                                 |                                                   |
|                                                 |                                                   |

- Revealing Module Pattern:
- Vermeiden: 
	- Redundanz und Object Literal Notation von MP
- Definition aller Funktionen und Vars im Privaten Scope
- Zurückgeben eines anonymen Objekts mit Verweisen auf die private Daten, die öffentlich zugänglich gemacht werden sollen.

| VT                                                | NT                                                  |
| ------------------------------------------------- | --------------------------------------------------- |
| Konsistente Syntax                                | Private Methoden können nicht mehr erweitert werden |
| Bessere Lesbarkeit des Codes                      | Ändern und Patchen von public ist schwerer          |
| einfacht änderung des Status (private und public) |                                                     |
| einfache Umbenennung                                                  |                                                     |

- Factory Pattern
- generisches Interface zur erzeugung von Objekten

| VT                                          | NT                                   |
| ------------------------------------------- | ------------------------------------ |
| Vereinfacht komplexe Objekterstllung        | Testen der Komponenten ist erschwert |
| ähnlich Instanziierungsprozess voraussetzen |                                      |

##### Strukturelle Pattern:
- Facade Pattern:
- Stellt eine reduzierte einheitliche Schnittstelle zur Verfügung

| VT                      | NT                                  |
| ----------------------- | ----------------------------------- |
| versteckt das Subsystem | Einführung einer Abstraktionschicht |
| geringere Komplexitäts  | Kosten/Nutzen zu einer Insellösung  |

##### Verhaltensorientierte Pattern:
- Observer Pattern:
- Subscription Model
	- Objekte registrieren bei einem Event
		- Push Notification $\Rightarrow$ Änderung wird gemeldet
		- Push-Update Notification  $\Rightarrow$  gleichzeitig geänderte Daten übertragen
		- Pull Notification $\Rightarrow$ Beobachter fragt beim beobachteten Objekt nach

| VT                                                        | NT                                              |
| --------------------------------------------------------- | ----------------------------------------------- |
| Unabhängig von Subjects und Observers                     | viele Observers, hohe Kosten                    |
| Minimale und abstrakte Kopplung der Komponenten           | Keine Information über den Inhalt               |
| Keine Kenntnis der Struktur zwischen Subject und Observer | Endlos- Schleifen und Event-hell                |
| Observer dynamisch registriebar                           | Zustand eines Programms schwer nachzuvollziehen |

- Mediator Pattern: 
- zentrale Autorität über eine Gruppe von Objekten

| VT                                                | NT                                |
| ------------------------------------------------- | --------------------------------- |
| Reduziert die Komplexität von Objekten            | Komplexität des Mediators         |
| Abstrakte Kopplung der Komponenten                | monolithischen Programmkonstrukts |
| Zentrales Verhalten unabhängig von den Colleagues | Preformance                       |

